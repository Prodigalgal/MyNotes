# 1、体系结构

## 1、概览



![20190125091610943](images/20190125091610943.gif)



## 2、分层

### 1、概述

网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能

一个**协议簇**，比如：

- TCP/IP，是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统



### 2、五层协议

**应用层**：为**特定应用程序**提供数据传输服务

- Telnet： 远程登录
- FTP：文件传输协议
- SMTP： 简单邮件传送协议
- SNMP：简单网络管理协议

**传输层**：为**主机中的进程**提供通用数据传输服务，属于端到端、进程之间

- 由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议，也就是弥补上三层与下三层数据传输服务质量之间的差异（差错率、差错恢复能力、吞吐率、延时、费用等），对高层屏蔽网络层的服务的差异，提供稳定和一致的界面
- 传输层会将数据分段，并进行必要的控制，以便将这些片段重组成各种通信流，在此过程中，传输层负责：
  - 跟踪源主机和目的主机上应用程序间的每次通信
  - 将数据分段，并管理每个片段
  - 将分段数据重组为应用程序数据流
  - 标识不同的应用程序

- 主要协议：
  - TCP：传输控制协议 （面向字节流 ）
  - UDP：用户数据报协议（面向数据报） 

**网络层**：为**主机**提供数据传输服务，属于点到点、主机之间

- 网络层把传输层传递下来的报文段或者用户数据报封装成分组
- 网络层的分组传输是不可靠的，无法了解数据到达终点的时间，无法了解数据未达终点的状态
- 相关协议：
  - IP 协议：网际协议
  - ICMP 协议：Internet 互联网控 制报文协议
  - IGMP 协议：Internet 组管理协议 

**数据链路层**：链路层协议就是为**同一链路的主机**提供数据传输服务

- 主机之间可以有很多链路
- 数据链路层把网络层传下来的分组封装成帧

**物理层**：考虑的是怎样**在传输媒体上传输数据比特流**，而不是指具体的传输媒体

- 物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异

<img src="images/image-20231019213945941.png" alt="image-20231019213945941" style="zoom:67%;" />

### 3、OSI 七层协议

**表示层**：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题

**会话层**：建立及管理会话

prc 协议：(远程方法调用协议)

<img src="images/image-20231019213933104.png" alt="image-20231019213933104" style="zoom:67%;" />

### 4、TCP/IP 四层协议

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层，该协议族的另一个名字是 Internet 协议族（Internet Protocol Suite）

**应用层**：负责处理特定的应用程序细节（FTP、Telnet）

**运输层**：主要为两台**主机**上的应用程序提供**端到端**的通信，提供可靠的服务

- 在 TCP/IP 协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）
  - TCP：为两台主机提供高可靠性的数据通信，它主要用于数据分块交付网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等，由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节
  - UDP：为应用层提供一种非常简单的服务，它只是把称作数据报的分组从一台主机发送到另一台主机，并不保证该数据报能到达另一端，任何必需的可靠性必须由应用层来提供

**网络层**：处理分组在网络中的活动，尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证，例如：分组的选路

**网络接口层**：也叫链路层，包括操作系统中的**设备驱动程序**和计算机中对应的**网络接口卡**，这俩协同处理任何传输媒介（电缆）的物理接口细节（以太网、令牌 环网等），其支持多种不同的链路层协议，这取决于网络所使用的硬件，如：以太网、令牌环网、FDDI 及 RS-232 串行线路等

- 链路层主要有三个目的：

  - 为 IP 模块发送和接收数据报

  - 为 ARP 模块发送请求和接收应答
  - 为 RARP 发送请求和接收应答


<img src="images/image-20220403213925936.png" alt="image-20220403213925936" style="zoom:50%;" /><img src="images/image-20231019213901454.png" alt="image-20231019213901454" style="zoom:60%;" /><img src="images/image-20231019214136842.png" alt="image-20231019214136842" style="zoom:67%;" /><img src="images/image-20220414174931377.png" alt="image-20220414174931377" style="zoom: 40%;" />

## 3、数据封装

元数据进行网络传输，需要先进行**逐层封装**和**逐层解析**的过程，如下图：

每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），也即向下的过程中，需要添加下层协议所需要的首部或者尾部

- TCP 和 UDP 都用一个 16 bit 的端口号来表示不同的应用程序，TCP 和 UDP 把源端口号和目的端口号分别存入报文首部中
- IP 协议在首部中存入一个长度为 8 bit的数值，称作协议域
  - 1 表示为 ICMP 协议
  - 2 表示为 IGMP 协议
  - 6 表示为 TCP 协议
  - 17 表示为 UDP 协议

**注意**：

- 以太网数据帧的物理特性是其长度必须在 46～1500 字节之间

![image-20231020203417910](images/image-20231020203417910.png)



## 4、数据分用

当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部

每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这个过程称作分用（Demultiplexing）

也即在向上的过程中不断拆开首部和尾部

<img src="images/image-20231020204352961.png" alt="image-20231020204352961" style="zoom:70%;" />

**注意**：

- ICMP 和 IGMP 报文都被封装在IP数据报中，因此放在 IP 层上方，ARP 与 RARP 同理



## 5、路由器

路由器是一种特殊的用于网络互连的硬件盒，也称作 IP 路由器（IP Router），用于在**网络层**上对网络进行互连

路由器的好处是为不同类型的物理网络提供连接：以太网、令牌环网、 点对点的链接和FDDI（光纤分布式数据接口）等等

从定义上看，一个路由器具有两个或多个网络接口层（因为它连接了两个或多个网络），但不一定指那种在互联网中用来转发分组的特殊硬件盒，拥有都接口的主机经过特殊设置也可以实现

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层



## 6、网桥

网桥是在**链路层**上对网络进行互连

网桥使得多个局域网（LAN）组合在一起，这样对上层来说就好像是一个局域网



## 7、网关

网关这个术语只用来表示应用层网关：一个连接两种不同协议族的进程（例如：TCP/IP 和 IBM 的 SNA）

网关为某个特定的应用程序服务（常常是电子邮件或文件传输）



## 8、端口号

### 1、基本概念

运行在计算机中的进程是用**进程标识符**来标志的，运行在应用层的各种应用进程却由于操作系统的不同，不能使用该方法，所以再运输层使用协议端口号(protocol port number)，或通常简称为端口(port)，来标识

一个应用进程可以绑定多个端口号，而一个端口号只能被一个应用进程绑定



### 2、端口号范围的划分

0 - 1023：知名端口号，HTTP，FTP，SSH等这些广为使用的应用层协议，其端口号都是固定的，由 IANA 机构分配

- 在 unix 中也叫做保留端口号，sroot 权限的进程才可分配

1024 - 65535：操作系统动态分配的端口号，客户端程序的端口号就是由操作系统从这个范围分配的

>/etc/service 文件可查知名端口号分配情况 



## 9、环回接口

环回接口允许运行在**同一台主机**上的客户程序和服务器程序通过 TCP/IP 进行通信

通常 127.0.0.1 分配给这个接口，并命名为 localhost，一个传给环回接口的 IP 数据报不能在任何网络上出现

网络层把一份数据报传送给环回接口，就像传给其他链路层一样，当环回数据回到上层的协议栈中时，它已经过传输层和 IP 层完整的处理过程

<img src="images/image-20231022100230693.png" alt="image-20231022100230693" style="zoom:67%;" />

**注意**：

-  传给环回地址的任何数据均作为 IP 输入
- 任何传给该主机I P地址的数据均送到环回接口



## 10、MTU

### 1、最大传输单元

以太网和 802.3 对数据帧的长度都有一个限制，其最大值分别是 1500 和 1492 字节，链路层的这个特性称作 MTU，最大传输单元

如果 IP 层有一个数据报要传，而且数据的长度比链路层的 MTU 还大，那么 IP 层就需要进行分片，把数据报分成若干片且均小于 MTU

<img src="images/image-20231022100946220.png" alt="image-20231022100946220" style="zoom: 80%;" />



### 2、路径 MTU

如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的 MTU，此时最重要的是两台主机网络路径之间的最小 MTU，其被称作路径 MTU

路径 MTU 不一定是固定的，它取决于所选取的路由，且由于来去路径不一定对称，因此来去 MTU 不一定相等



## 11、串行线路吞吐量计算

$$
耗时 = \frac{数据长度}{线路速率}
$$



# IP 协议

## 1、概览

IP 协议在 OSI 七层协议中位于**网络层**，在物理层和链路层之上，网络层是整个互联网的核心，使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络

IP 协议是 TCP/IP 协议族中最为核心的协议，所有的 TCP、UDP、ICMP、IGMP 数据都以 IP 数据报格式传输，如果协议版本号是 4，IP 协议也称作 IPv4

IP 数据报传送服务具有不可靠性、无连接性：

- **不可靠性**（unreliable）：
  - 意思是它不能保证 IP 数据报能成功地到达目的地
  - IP 仅提供最好的传输服务，如果发生某种错误时，如某个路由器暂时用完了缓冲区， IP 有一个简单的错误处理算法：丢弃该数据报，然后发送 ICMP 消息报给信源端
  - 任何要求的可靠性必须由上层来提供（如 TCP）

- **无连接性**（connectionless）：
  - 这个术语的意思是 IP 并不维护任何关于后续数据报的状态信息
  - 每个数据报的处理是相互独立的，这也说明， IP 数据报可以不按发送顺序接收，如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是 B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B 可能在 A 到达之前先到达


与 IP 协议配套使用的还有三个协议：

- 地址解析协议 ARP（Address Resolution Protocol）
- 网际控制报文协议 ICMP（Internet Control Message Protocol）
- 网际组管理协议 IGMP（Internet Group Management Protocol）

IP 数据报传输次序：

- 最高位在左边，记为 0 bit，最低位在右边，记为 31 bit，一共 32 bit，4 个字节的 32 bit 值以下面的次序传输：首先是 0～7 bit，其次 8～15 bit，然后 16～23 bit， 最后是 24~31 bit，这种传输次序称作 big endian 字节序，又称作网络字节序，其他字节序发送前需要转换



## 2、IP 分类

IP 地址长为 **32 bit**，地址具有一定的结构，这些 32 位的地址通常写成**四个十进制**的数，其中每个整数对应一个 byte，这种表示方法称作点分十进制表示法（Dotted decimal notation）

五类不同的**互联网地址格式**下：

![image-20231020004000332](images/image-20231020004000332.png)

各类 IP **地址的范围**：

| 类型 | 范 围                                |
| ---- | ------------------------------------ |
| A    | **0**.0.0.0 到 **127**.255.255.255   |
| B    | **128**.0.0.0 到 **191**.255.255.255 |
| C    | **192**.0.0.0 到 **223**.255.255.255 |
| D    | **224**.0.0.0 到 **239**.255.255.255 |
| E    | **240**.0.0.0 到 **247**.255.255.255 |

**三类IP地址**：

- 单播地址（目的为单个主机）
- 广播地址（目的端为给定网络上的所有主机）
- 多播地址（目的端为同一组内的所有主机）

**注意**：

- 多接口主机具有多个 IP 地址，其中每个接口都对应一个 IP 地址



## 3、IP 数据报格式

首部长度字段：

- 首部长度指的是首部占 32 bit 字的数目（包括选项栏），由于首部长度是一个 4 bit 字段，因此首部最长为 60 个 byte
- 普通 IP 数据报（没有任何选择项）字段的值是 5，因此普通的 IP 首部长度为 20 个 byte

服务类型 TOS 字段：

- 一个 3 bit 的优先权子字段（现在已被忽略）
- 一个 4 bit 的 TOS 子字段，分别代表：最小时延、最大吞吐量、最高可靠性和最小费用，4 bit 中只能置其中 1 bit，如果所有 4 bit 均为 0，那么就意味着是一般服务
- 一个 1 bit 未用位但必须置 0

8 位生存时间 TTL 字段：

- TTL（time - to - live）生存时间字段设置了数据报可以经过的最多路由器数，它指定了数据报的生存时间
- TTL 的初始值由源主机设置（通常为 32 或 64），一旦经过一个处理它的路由器， 它的值就减去 1，当该字段的值为 0 时，数据报就被丢弃，并发送 ICMP 报文通知源主机

16 位首部检验和字段：

- 根据 IP 首部计算的检验和码，用于验证传送数据报和接受数据报的差异，不对首部后面的数据进行计算
- 首先把检验和字段置为 0，对首部中每个 16 bit 进行二进制反码求和 ，结果存在检验和字段中，收到数据报后再对首部进行计算，相同就把检验和字段置为 1，不同那么IP就丢弃收到的数据报 ，但是不生成差错报文，由上层去发现丢失的数据报并进行重传

总长度字段：

- 占用 16 位二进制位，总长度字段是指整个 IP 数据报的长度（报头区+数据区），以字节为单位
- 利用首部长度字段和总长度字段， 就可以知道 IP 数据报中数据内容的起始位置和长度，由于该字段长 16 bit，所以 IP 数据报最长可达 65535 字节

标识字段：

- 唯一地标识主机发送的每一份数据报，通常每发送一份报文它的值就会加 1  

<img src="images/image-20231022110124179.png" alt="image-20231022110124179" style="zoom:60%;" /><img src="images/image-20231022111147228.png" alt="image-20231022111147228" style="zoom:60%;" />



## 4、IP 路由选择

对于主机来说 IP 路由选择是简单的，如果目的主机与源主机直接相连或都在一个共享网络上，那么 IP 数据报就直接送到目的主机上，否则主机把数据报发往默认路由器，由路由器来转发该数据报

IP 路由选择是逐跳地（hop-by-hop）进行的，所有的 IP 路由选择只为数据报传输提供下一站路由器的 IP 地址

 IP 层在内存中有一个路由表，当收到一份数据报并进行发送时，它搜索该表一次，当数据报来自某个网络接口时：

1. IP 首先检查**目的 IP 地址**是否为本机的 IP 地址之一或者 IP 广播地址：
   1. 如果是，数据报就被送到由 IP 首部协议字段所指定的协议模块进行处理
   2. 如果数据报的目的不是这些地址
      1. 如果 IP 层被设置为路由器的功能，那么就对数据报进行转发
      2. 否则数据报被丢弃

**路由表信息内容**：

- 目的 IP 地址：
  - 既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定
  - 主机地址有一个非 0 的主机号，以指定某一特定的主机，而网络地址中的主机号为 0，以指定网络中的所有主机（如以太网，令牌环网）
- 下一站（或下一跳）路由器（next-hop router）的 IP 地址，或者有直接连接的网络 IP 地址：
  - 下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报
  - 下 一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的
- 标志：
  - 一个标志指明目的 IP 地址是网络地址还是主机地址
  - 一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口
- 为数据报的传输指定一个网络接口

**IP 路由选择功能**：如果以下步骤都失败，则该数据包不传送，如果该包来自本机，则会返回主机/网络不可达的错误

1. 搜索路由表，寻找能与目的 IP 地址完全匹配的表目（网络号和主机号都要匹配）如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）
2. 搜索路由表，寻找能与目的网络号相匹配的表目，如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值），目的网络上的所有主机都可以通过这个表目来处置，这种搜索网络的匹配方法必须考虑可能的子网掩码
3. 搜索路由表，寻找标为默认的表目，如果找到，则把报文发送给该表目指定的下一站路由器

**注意**：

- 所有的路由选择决策都是基于目的 IP 地址
- 链路层首部永远只想下一站链路层 IP 地址



路由器或者主机将会用如下的方式来处理某一个IP数据包：

- 如果 IP 数据包的 TTL (生命周期)以到，则该IP数据包就被抛弃
- 搜索路由表，优先搜索匹配主机，如果能找到和 IP 地址完全一致的目标主机，则将该包发向目标主机
- 搜索路由表，如果匹配主机失败，则匹配同子网的路由器，这需要“子网掩码(1.3.)”的协助，如果找到路由器，则将该包发向路由器
- 搜索路由表，如果匹配同子网路由器失败，则匹配同网号路由器，如果找到路由器，则将该包发向路由器
- 搜索路由表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包
- 如果都失败了，就丢掉这个包

这再一次证明了，IP 包是不可靠的，因为它不保证送达



## 5、子网寻址

IP 地址的定义是 **网络号** + **主机号**，但是现在所有的主机都要求子网编址，也就把主机号在细分成 **子网号 **+ **主机号**

最终一个 IP 地址就成为 **网络号** + **子网号** + **主机号**

下面就是一个 B 类地址：

![image-20231022165746676](images/image-20231022165746676.png)

B 类网络地址 （140.252），在剩下的 16 bit 中，8 bit 用于子网号，8 bit 用于主机号，这样就允许有 254 个子网，每个子网可以有 254 台主机（8 位一共有 256 种可能，由于全 0 或全 1 的主机号都是无效的， 所以就有 254 种可能）

划分子网的主要目的就是为了缩减路由表的规模



## 6、子网掩码

主机需要知道有多少 bit 用于子网号（通常是网络号 + 子网号）及多少 bit 用于主机号，这些都是通过子网掩码判断的，如果知道本机的 IP 地址，那么就知道它是否为 A 类、B 类、C 类地址（从 IP 地址的高位可以得知），也就知道**网络号**和**子网号**之间的分界线，而根据子网掩码就可知道**子网号**与**主机号**之间的**分界线**

子网掩码是一个 32 bit 的值，其中值为 **1 的 bit 留给网络号和子网号**，为 **0 的 bit 留给主机号**

通过将子网掩码与IP地址进行**与**操作，可求出 IP 地址所属的网络号（包括子网络号）

给定 IP 地址和子网掩码以后，主机就可以确定 IP 数据报的目的地是：

1. 本子网上的主机
2. 本网络中其他子网中的主机
3. 其他网络上的主机

<img src="images/image-20231022170925730.png" alt="image-20231022170925730" style="zoom:67%;" />

<img src="images/image-20231022171408629.png" alt="image-20231022171408629" style="zoom:67%;" />

IP 地址分类对应的默认子网掩码：

- A类：255.0.0.0
- B类：255.255.0.0
- C类：255.255.255.0



## 7、子网划分

把 IP 地址进一步划分为更小的网络，即子网划分，经过子网划分后，IP 地址的子网掩码不再是具有标准的标准 IP 地址的掩码，由此 IP 地址可以分为两类：有类地址、无类地址

- 有类地址：标准的 IP 地址（A、B、C 三类）属于有类地址，例如：A 类地址掩码 8 位，B 类地址掩码 16 位，C 类地址掩码 24 位


- 无类地址（CIDR）：对 IP 地址进行子网划分，划分后的 IP 地址不再具有有类地址的特征，只是用子网掩码来区分网络号和主机号

例1：

>11111111 11111111 11111111 00000000  连续的1代表网络位，连续的0代表主机位，转换为 255.255.255.0
>
>根据掩码规则
>
>- 由于 1 代表网络和子网号，因此 255.255.255 代表网络位
>- 最后的 0 代表主机位
>
>假设 IP 为 192.168.33.112 ，则 192.168.33 为网络为，112 为主机位，以此划分子网

例2：

>172.31.128.255/18，这里使用了 CIDR 表示法，即 / 后面跟上数字
>
>其中 18 表示，高位开始连续 18 个 1
>
>11111111 11111111 11000000 00000000 转换为 255.255.192.0 

**计算网络号**：将 IP 地址的二进制和子网掩码的二进制进行 & 运算

**计算主机号**：用 IP 地址的二进制和子网掩码的二进制的反码进行 & 运算

**计算广播地址**：计算子网掩码中表示主机号的数量 n，将网络号从右开始填 n 次 1

**计算子网数**：对比 ABC 类默认子网掩码，借了 n 位为网络号，则子网数为 2^n

- A：8 ≤ 子网掩码 < 16，n = 子网掩码 - 8
- B：16 ≤ 子网掩码 < 24，n = 子网掩码 - 16

- C：24 ≤ 子网掩码 < 32，n = 子网掩码 - 24

**计算主机数**：网络号 + 1 ~ 广播地址 - 1 或者 2^N - 2，其中 N 为主机号位数

- N = 32 - 子网掩码为 1 的位数

| 192.168.1.0 | /24  | /25  | /26  | /27  | /28  | /29  | /30  | /31  | /32  |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 子网掩码    | 0    | 128  | 192  | 224  | 240  | 248  | 252  | 254  | 255  |
| 子网个数    | 1    | 2    | 4    | 8    | 16   | 32   | 64   | 128  | 256  |
| IP 数量     | 256  | 128  | 64   | 32   | 16   | 8    | 4    | 2    | 1    |
| IP 个数     | 254  | 126  | 62   | 30   | 14   | 6    | 2    | 2    | 1    |

>例子：192.168.1.0/24
>
>I P  地址：11000000.10101000.00000001.00000000 => 192.168.1.0
>
>子网掩码：11111111.11111111.11111111.00000000 => 255.255.255.0
>
>网 络 号  ：11000000.10101000.00000001.00000000 => 192.168.1.0
>
>广播地址：11000000.10101000.00000001.11111111 => 192.168.1.255
>
>子网数量：2^0 = 1
>
>主机数量：192.168.1.1 ~ 192.168.1.254



## 8、变长子网





## 9、特殊 IP 地址

表的头两项是特殊的源地址，中间项是特殊的环回地址， 最后四项是广播地址

<img src="images/image-20231022172738726.png" alt="image-20231022172738726" style="zoom:80%;" />

0 表示所有的比特位全为 0

-1 表示所有的比特位全为 1

netid、subnetid、hostid 分别表示不为全 0 或全 1 的对应字段

子网号栏为空表示该地址没有进行子网划分



#  SLIP 协议

## 1、概述

一种在串行线路上对 IP 数据报进行封装的简单形式，一般提供基于服务类型的排队方法，允许对交互通信数据在处理大块数据之前进行处理

SLIP 协议帧格式：

- IP 数据报以一个称作 END（0 x c0）的特殊字符结束，且为了防止数据到来前的数据噪声，会在前面也放置一个 END

- 如果 IP 报文中某个字符为 END，那么就要连续传输两个字节 0xdb（ESC字符） 和 0xdc 来取代它
- 如果 IP 报文中某个字符为  SLIP 的 ESC 字符，那么就要连续传输两个字节 0xdb 和 0xdd 来取代它

<img src="images/image-20231021173921755.png" alt="image-20231021173921755" style="zoom:67%;" />



## 2、CSLIP 协议

由于串行线路的速率通常较低（19200 b/s 或更低），且由于交互式通信，SLIP 协议上有许多小的 TCP 分组交换，而 CSLIP 可以对数据压缩，并在每端维持多达 16 个 TCP 连接，



# PPP 协议

PPP 协议包括以下三个部分：

- 在串行链路上封装 IP 数据报的方法，既支持数据为 8 位和无奇偶检验的异步模式，还支持面向比特的同步链接
- 建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol），它允许通信双方进行协商，以确定不同的选项
- 针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系，当前 RFC 定义的网络层有 IP、OSI 网络层、DECnet 以及 AppleTalk

<img src="images/image-20231022095000849.png" alt="image-20231022095000849" style="zoom:67%;" />

PPP 比 SLIP 具有下面这些优点：

- PPP 支持在单根串行线路上运行多种协议， 不只是 IP 协议
- 每一帧都有循环冗余检验
- 通信双方可以进行 IP 地址的动态协商（使用 IP 网络控制协议）
- TCP 和 IP 报文首部进行压缩
- 链路控制协议可以对多个数据链路选项进行设置







# ARP 协议

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信

在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变，ARP 实现由 IP 地址得到 MAC 地址，称为地址解析协议

每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址 到 MAC 地址的映射表

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射

![image-20220403220407639](images/image-20220403220407639.png)

![image-20220403220819076](images/image-20220403220819076.png)

![image-20220403220947224](images/image-20220403220947224.png)



# ICMP 协议

ICMP（网际控制报文） 经常被认为是 IP 层的一个组成部分

ICMP 传递差错报文以及其他需要注意的信息

ICMP 报文通常被IP层或更高层协议（ TCP 或 UDP ）使用，例如一些 ICMP 报文把差错报文返回给用户进程

当传送IP数据包发生错误，比如主机不可达，路由不可达等等，ICMP 协议将会把错误信息封包，然后传送回主机并给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因，ICMP 数据包由 8 bit 的错误类型和 8 bit 的代码和 16 bit 的校验和组成，而前16bit就组成了ICMP所要传递的信息

<img src="images/image-20220403221307676.png" alt="image-20220403221307676" style="zoom:50%;" />

在大多数情况下，错误的包传送应该给出ICMP报文，但是在特殊情况下，是不产生ICMP错误报文的

- 如下 (所有的这一切规定，都是为了防止产生ICMP报文的无限传播而定义的)
  - ICMP差错报文不会产生ICMP差错报文（出IMCP查询报文）（防止IMCP的无限产生和传送）

  - 目的地址是广播地址或多播地址的IP数据报

  - 作为链路层广播的数据报

  - 不是IP分片的第一片

  - 源地址不是单个主机的数据报，这就是说，源地址不能为零地址、环回地址、广播地址或多播地址


ICMP协议大致分为两类，一种是查询报文，一种是差错报文，其中查询报文有以下几种用途 :

- ping查询

- 网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）

- 时间戳查询（可以用来同步时间)。

<img src="images/image-20220403221451137.png" alt="image-20220403221451137" style="zoom:50%;" />

**PING**：

Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性

Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文

Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率



**Traceroute**：

Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径

Traceroute 发送的 IP 数据报封装的是无法交付的UDP用户数据报，并由目的主机发送终点不可达差错报告报文

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报文
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间



# UDP 协议

## 1、概述

UDP 是一个简单的**面向数据报**的运输层协议：进程的**每个输出操作都正好产生一个 UDP 数据报**，**并组装成一份待发送的 IP 数据报**

- 一个数据报是指从发送方传输到接收方的一个信息单元（例如：发送方指定的一定字节数的信息）

这与面向字节流的协议不同，如：TCP，应用程序产生的全体数据与真正发送的单个 IP 数据报可能没有什么联系

用户数据报协议 UDP（User Datagram Protocol）是**无连接的**，**尽最大可能交付**，**没有拥塞控制**，**面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），**支持一对一**、**一对多**、**多对一**和**多对多**的交互通信

**注意**：

- UDP 是传输层协议，和 TCP 协议处于一个分层中，但是与 TCP 协议不同，UDP 协议并不提供**超时重传**，**出错重传**等功能，也就是说其是不可靠的协议



## 2、UDP首部

UDP的首部占8个字节，其内容数据如下图：

![image-20220403222617495](images/image-20220403222617495.png)

在ip首部为20个字节，由于数据封装是逐层进行的所有UDP的数据报为下图：

![image-20220403222652418](images/image-20220403222652418.png)



### 1、UDP端口号

由于很多软件需要用到UDP协议，所以UDP协议必须通过某个标志用以区分不同的程序所需要的数据包

端口号的功能就在于此，例如某一个UDP程序A在系统中注册了3000端口，那么，以后从外面传进来的目的端口号为3000的UDP包都会交给该程序

端口号理论上可以有2^16这么多，因为它的长度是16个bit



### 2、UDP检验和

- UDP和TCP在首部中都有覆盖它们首部和数据的检验和，UDP的检验和是可选的，而TCP的检验和是必需的（伪首部的长度为12个字节，所以TCP的长度一定为20）
- UDP检验和 覆盖UDP协议头 和 数据，这和 IP的检验和 是不同的，IP协议的检验和 只是覆盖 IP数据头，并不覆盖所有的数据
- UDP和TCP都包含一个伪首部，这是为了计算 检验和 而设置的，伪首部甚至还包含IP地址这样的IP协议里面都有的信息，目的是让UDP两次检查数据是否已经正确到达目的地
  - 如果发送端没有打开 检验和 选项，而接收端计算 检验和 有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文

![image-20220403223125633](images/image-20220403223125633.png)



## 3、UDP长度

理论上，IP数据报的最大长度是64K(65535字节)（2的16次幂），这是由IP首部16比特总长度字段所限制的，去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节，但是一般网络在传送的时候，一次一般传送不了那么长的协议（涉及到MTU的问题），就只好对数据分片，这些是对UDP等上级协议透明的，UDP不需要关心IP协议层对数据如何分片

在一个以太网上，数据帧的最大长度是 1500字节 ，假定IP首部为20字节， 而且UDP首部为8字节，所以每片UDP最大数据为1472个字节

<img src="images/image-20220403224005201.png" alt="image-20220403224005201" style="zoom:50%;" />

1. IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后）
2. 分组是指在IP层和链路层之间传送的数据单元，一个分组可以是一个完整的IP数据报， 也可以是IP数据报的一个分片



## 4、UDP服务器设计

- 关于客户IP和地址：服务器必须能根据客户IP地址和端口号判断数据包是否合法
- 关于目的地址：服务器必须要有过滤广播地址的能力
- 关于数据输入：通常服务器系统的每一个端口号都会和一块输入缓冲区对应，进来的输入根据先来后到的原则等待服务器的处理，所以难免会出现缓冲区溢出的问题，这种情况下，UDP数据包可能会被丢弃，而应用服务器程序本身并不知道这个问题
- 服务器应该限制本地IP地址：它应该可以把自己绑定到某一个网络接口的某一个端口上



## 5、UDP的应用

三种IP地址：单播地址、广播地址和多播地址 ，广播和多播仅应用于UDP

> 有时一个主机要向网上的所有其他主机发送帧， 这就是广播 
>
> 多播 (multicast) 处于单播和广播之间：帧仅传送给属于多播组的多个主机
>

>
> 广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要 
>
> TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接

IP多播提供两类服务：

- 向多个目的地址传送数据。向多个接收者传送信息的应用：例如交互式会议系统，向多个接收者分发邮件或新闻，不过某些应用可能采用TCP来保证它的可靠性

- 客户对服务器的请求，例如，无盘工作站需要确定启动引导服务器，这项服务是通过广播来提供的，但是使用多播可降低不提供这项服务主机的负担



# TCP 协议

## 1、概述

TCP 和 UDP 都使用相同的网络层的 IP 协议，但是 TCP 却向应用层提供与 UDP 完全不同的服务

TCP 提供一种**面向连接**的、**可靠**的**字节流**服务

TCP 要比 UDP 可靠的多，UDP 是把数据包直接发出去，而不管对方是不是在收信，就算是 UDP 无法送达，也不会产生 ICMP 差错报文



## 2、可靠的TCP

TCP保证可靠性的简单工作原理如下：

1. 应用数据被分割成TCP认为最适合发送的数据块，这和UDP完全不同，TCP发送数据报长度将保持不变，由TCP传递给IP的信息单位称为报文段或段（segment）
2. 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段
3. 当收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送， 通常将推迟几分之一秒
4. TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化，如果收到段的检验和有差错， TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）
5. TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序，所以如果有必要， TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层
6. 由于IP数据报会发生重复，TCP的接收端必须丢弃重复的数据
7. TCP还能提供流量控制，TCP连接的双方都有固定大小的缓冲空间， TCP的接收端只允许发送端发送接收端缓冲区所能接纳的数据，这将防止较快主机致使较慢主机的缓冲区溢出



由此可以看出TCP使用**超时重传**来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段

**RTT**：一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：
$$
RTTs=(1−a)∗(RTTs)+a∗RTT
$$
**RTO**：超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：
$$
RTO=RTTs+4∗RTTd
$$



## 3、TCP首部格式

<img src="images/image-20220411204522204.png" alt="image-20220411204522204" style="zoom:50%;" />

- **序号**：发送序号(Sequence Number)，用于对字节流进行编号，表示在这个报文段中的第一个数据字节的顺序号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。当建立一个新的连接时， SYN标志变 1，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN（ Initial Sequence Number）
- **确认号 ack**：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701
- **数据偏移**：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度
- **确认标记 ACK**：当 ACK=1 时确认号字段有效，否则无效，TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1
- **同步标记 SYN**：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段，若对方同意建立连接，则响应报文中 SYN=1，ACK=1
- **终止 FIN**：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接
- **窗口**：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的
- **端口号**：源端口号(Source Port)和目标端口号(Destination Port)，源端口号标识了发送主机的进程，目标端口号标识接受方主机的进程



## 4、TCP的三次握手

<img src="images/image-20220411205046438.png" alt="image-20220411205046438" style="zoom:50%;" />

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x
- B 收到连接请求报文，如果同意建立连接则向 A 发送连接确认报文，SYN=1，ACK=1，确认号是连接请求报文中的初始序号+1即为 x+1，同时也选择一个初始的序号 y
- A 收到 B 的连接确认报文后，还要向 B 发出确认，其中确认号为收到的连接确认报文中的序号+1即为 y+1，同时序号为 初始序号+1
- B 收到 A 的确认后，连接建立



**三次握手的原因**：第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接

1. 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认
2. 客户端等待一个超时重传时间之后，就会重新请求连接，但是这个滞留的连接请求最后还是会到达服务器
3. 如果不进行三次握手，那么服务器就会打开两个连接，如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，不会再次打开连接




## 5、TCP的四次挥手

<img src="images/image-20220411205734134.png" alt="image-20220411205734134" style="zoom:50%;" />

- A 发送连接释放报文，FIN = 1，seq = u
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据，ACK = 1，seq = v， ack = u + 1
- 当 B 不再需要连接时，发送连接释放报文，FIN = 1，ACK = 1，seq = w，ack = u + 1
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接，ACK = 1，seq = u + 1，ack = w + 1
- B 收到 A 的确认后释放连接



**四次挥手的原因**：

- 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态，这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文



**TIME_WAIT** 作用：

- 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL这么做有两个理由：

  - 确保最后一个确认报文能够到达，如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生

  - 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文



## 6、TCP滑动窗口

窗口是缓存的一部分，用来暂时存放字节流

- 发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收

- 如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态，接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口

接收窗口只会对窗口内最后一个按序到达的字节进行确认

- 例如接收窗口已经收到的字节为 {31，34，35}，其中 {31} 按序到达，而 {34，35} 就不是，因此只对字节 31 进行确认
- 发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收

<img src="images/image-20220411210631543.png" alt="image-20220411210631543" style="zoom:70%;" />



## 7、TCP流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率

将窗口字段设置为 0，则发送方不能发送数据



## 8、TCP拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高，因此当出现拥塞时，应当控制发送方的速率

这一点和流量控制很像，但是出发点不同，流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度

<img src="images/image-20220411210907723.png" alt="image-20220411210907723" style="zoom:50%;" />

TCP 主要通过四个算法来进行拥塞控制：**慢开始**、**拥塞避免**、**快重传**、**快恢复**

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量

**注意**：

- 拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口

<img src="images/image-20220411211326363.png" alt="image-20220411211326363" style="zoom:70%;" />

**慢开始与拥塞避免**：

1. 发送方最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段，当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …

2. 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高，设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

3. 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始

<img src="images/image-20220411211549815.png" alt="image-20220411211549815" style="zoom:70%;" />

**快重传与快恢复**：

1. 对于接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。
2. 对于发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。
3. 在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。



# 7、DNS

## 1、概述

在 TCP/IP 领域中，域名系统（DNS）是一个分布的数据库，由它来提供 IP 地址和主机名之间的映射信息





# 扩展

## 1、NIC 机构

由于互联网上的每个接口必须有一个唯一的 IP 地址，因此必须要有一个管理机构为接入互联网的网络分配 IP 地址，这个管理机构就是互联网络信息中心（Internet Network Information Centre），称作 InterNIC，其只分配网络号，主机号的分配由系统管理员来负责

Internet 注册服务（IP 地址和 DNS 域名）过去由 NIC 来负责，其网络地址是 nic.ddn.mil，1993 年 4 月 1 日，InterNIC 成立，现在 NIC 只负责处理国防数据网的注册请求，所有其他的 Internet 用户注册请求均由 InterNIC 负责处理，其网址是：rs.InterNIC.net

事实上 InterNIC 由三部分组成：

- 注册服务（rs.InterNIC.net）
- 目录和数据库服务（ds.InterNIC.net）
- 以及信息服务（is.InterNIC.net）



## 2、IEEE 802

<img src="images/image-20231021173110403.png" alt="image-20231021173110403" style="zoom:67%;" />



# 问题

## 1、TCP/UDP的不同

首先TCP和UDP都是传输层协议，它们的网络层协议都是IP协议，而IP协议具有两个特点：无连接、不可靠

UDP（用户数据报协议）保留IP协议的特点，常用于广播和多播，UDP协议不可靠

TCP（传输控制协议 (面向字节流的协议)）通过三次握手机制，为客户端和服务器提供全双工服务，同时还提供了超时和重发机制，保证传输数据不被丢失，并且TCP协议还能进行流量控制与拥塞控制



## 2、TCP协议如何保证数据不被丢失

网络层协议还有个ICMP协议，ICMP协议常常认为是IP协议的一部分，由于IP协议对上层运输层和下层物理链路层是透明的，当发送数据报被丢弃时，ICMP会把错误信息反馈给TCP，而UDP不会得到任何返回信息，TCP解析后会进行数据重传，由于IP发送数据报可能会分片发送，TCP协议还会对数据进行重排后给应用层



## 3、为什么ICMP会把数据报返回给TCP而不是UDP

TCP的首部长度为20个字节，而UDP的首部长度为8字节，多的12个字节中有4个字节保存的是32位的ICMP信息，而ICMP数据包由8bit的错误类型和8bit的代码和16bit的校验和组成



## 4、TCP和UDP每次传输的数据大小

首先UDP是无连接的，发送一次数据报连接就断开了，并且 **32位IP 是由4位（版本）+ 4位（头长度）+ 8位（服务类型）+ 16位（总长度：报头区+数据区）组成的**，所以最大传输数据为2的16次幂64K，还有 **UDP首部8位**，**IP首部20位**，所以UDP理论最大传输数据为**64K - 20bit - 8bit**（事实上受物理网络的限制，涉及MTU，因此要比这个数值小很多，实际上1472字节）

TCP提供全双工服务，由于物理网络层一般要限制每次发送数据帧的最大长度，IP发送数据会分片发送，MTU（网络传输最大报文包）最大值为1500bit，所以TCP数据报最大为1500-20-20=1460bit（IP首部和TCP首部都是20bit），理想状态下MSS（网络传输数据最大值）等于MTU，当然如果对于非本地的IP，这个MSS可能就只有536字节，而且，如果中间的传输网络的MSS更小的话，这个值还会减小



## 5、面向连接和面向无连接

面向连接的：信息发送方需要与接收方联系并通过联系来维持一个对话，且希望接收方能顺序接收所有内容，也即需要维护后继分组

无连接的：没有任何预先联系就发送消息，且不保证接收顺序，也即每个分组独立

TCP面向连接，UDP面向无连接（在默认的阻塞模式下）：

- 在TCP协议中，当客户端退出程序或断开连接时，TCP协议的recv函数会立即返回不再阻塞，因为服务端知道客户端已经退出或断开连接，证明它是面向连接的

- 在UDP协议中，recvfrom这个接收函数将会始终保持阻塞，因为服务端不知道客户端已经退出或断开连接，证明它是面向无连接的




## 6、面向字节流和面向数据报

面向字节流：不论应用层发送给TCP的数据报长度多少，TCP都把应用层产生的数据报看成是一连串的无结构的字节流，依靠TCP自身的缓冲，当数据报超过缓存长度，就把这些数据报切割成等长后发送，如果数据报小于缓存长度，TCP可以等待填满缓存再发送

面向报文：面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文，因此应用层必须选择合适大小的报文，若报文太长，则IP层需要分片，降低效率，若太短，会导致IP报文首部长度过长，同样降低效率



## 7、在默认的阻塞模式下，TCP无边界UDP有边界

TCP：客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即使客户端是分好几次发过来，但是服务端却能一次性接收过来，所以证明是无边界的

UDP：客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，也就是客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的



## 8、UDP 如何发送大量的数据？如何处理分包？

用UDP一次不能发送太大的数据量，不然就会报错：发送的消息大于内部消息缓冲器或其他一些网络限制，或用于接收数据报的缓冲器比数据报小

首先在客户端将要发送的内容分块，每块内容进行编号然后发送，服务端在接收到你的分块数据以后，根据你的客户端数据内容的编号重新组装，一般在发送数据的时候，尽量采用比较小的数据块的方式，数据块太大的话容易出现发送和接收的数据时间长，匹配出问题



## 9、TCP粘包原因以及解决

**出现原因**：

- 发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包
  - Nagle算法：会在上一个分组确认后，发送下一个分组，并且合并小包在一个确认到达时发送
  - 所以所谓的粘包，即前一份Send的数据跟后一份Send的数据可能会暂存到缓冲当中，然后一起发送

- 接收端TCP接收到数据包时，应用层并不会立即处理，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包

<img src="images/image-20221016184256030.png" alt="image-20221016184256030" style="zoom:50%;" />



**解决方法**：

- 关闭Nagle算法，使用TCP_NODELAY选项来关闭算法

- TCP只要保证自己写入的流是按 长度 + 内容 + 长度 + 内容 就可以解决粘包问题，不要采用所谓的 开始标识 + 数据 + 结束标识 来分包，适用性极低，错误率极高，除非数据都是固定有格式，否则是不能采用这种方式的



UDP就不同了，面向报文形式，系统是不会缓冲的，也不会做优化的，Send的时候，就会直接Send到网络上，对方收不收到也不管，所以这块数据总是能够能一包一包的形式接收到，而不会出现前一个包跟后一个包都写到缓冲然后一起Send

UDP传送当中，只存在丢包的可能，收到包的时候，肯定这个包的内容就是正确的，很少会有错误的，因为UDP本身也会用CRC32进行验证，还有长度验证，验证不通过，系统自动就会丢弃



## 10、UDP丢包原因

**丢包原因**：

- 接收端处理时间过长导致丢包，前一次调用rece方法接收处理数据时间过长，下一次发送包后不能及时recv导致丢包
- 发送的包过大，超过接受者缓存导致丢包，或者切分后数量过多丢包
- 发送的包频率太快，UDP的SendTo不会造成线程阻塞，它不保证当执行下一条语句时数据是否被发送，如果要发送的数据过多或者过大，那么在缓冲区满的那个瞬间要发送的报文就很有可能被丢失
- 缓存太小，不能及时接收数据

**解决方法**：

- 将接收的包放入缓存，尽量在最短的时间继续接收下一个（多线程回调机制）
- socket接收缓冲增大
- sleep，暂缓发包
- 在应用层自己实现丢包重发机制，超时机制，常见的可靠传输算法有模拟TCP协议，重发请求（ARQ）协议，它又可分为连续ARQ协议、选择重发ARQ协议、滑动窗口协议

TCP在建立连接时有三次握手的过程，这样就保证的连接的有效性，发包时发包完成也有反馈（对方接收完成有标记），所以TCP不存在丢包乱序的问题，但是发包过于频繁时会出现粘包的问题

UDP建立连接并没有三次握手的过程，而且发送数据只是负责发送，不会有发送成功的反馈，所以当数据量大会被切分为多个小数据发包时会出现丢包现象



## 11、计算各类 IP 地址数量

$$
最大网络数量（网段） = 2^{网络号位} - 2
$$

$$
最大主机数 = 2^{主机号位} - 2
$$

减 2 是因为除两个保留地址





